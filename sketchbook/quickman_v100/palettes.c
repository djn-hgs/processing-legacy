// -------------------------------------------------------------------------------------
// palettes.c -- Palette code for the QuickMAN SSE/SSE2-based Mandelbrot Set calculator
// Copyright (C) 2006 Paul Gentieu (paul.gentieu@yahoo.com)
//
// This file is part of QuickMAN.
//
// QuickMAN is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
//
// -------------------------------------------------------------------------------------
//
// 1/26/08 PG: Started v1.0 from v0.95. Removed previous comments. See v0.95 for previous 
// comments and history.
//
// Changed palette mapper to take separate line sizes for bitmap data and iteration data.
// Iteration data array requires two extra dummy pixels at the end of each line.
//
// Made a multithreaded version of the palette mapper. Can be activated with a #define. 
// Doesn't seem worthwhile... couldn't measure any benefit. 


#define STRICT
#define WIN32_LEAN_AND_MEAN

#define _WIN32_WINNT 0x501    // Windows XP

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

#define _USE_MATH_DEFINES

#define NUM_PALETTES 14

// Multi-threading the palette functions doesn't seem to speed things up much. 
// Define this to try it 

// #define PAL_MULTITHREADED

typedef struct
{
   // Arrays of dwords: msb is 0, lower 3 bytes are RGB triplets.
   // Can have variable-size palettes, given by size field.
   unsigned *rgb;
   int size;
} palette;

// Last entry is reserved for the user palette.
static palette palettes[NUM_PALETTES + 1] =
{
   {NULL, 256}, {NULL, 256}, {NULL, 256}, {NULL, 256},
   {NULL, 256}, {NULL, 256}, {NULL, 256}, {NULL, 256},
   {NULL, 256}, {NULL, 256}, {NULL, 256}, {NULL, 256},
   {NULL, 256}, {NULL, 256}, {NULL, 0}
};

//#define PAL_GENERATE // #define this to generate the palettes, instead of using arrays
#ifdef PAL_GENERATE

static int current_palette = 0;

// Uses global "current_palette". Assumes inputs are limited to 8 bits
static void setRGBpalette(int ind, int red, int green, int blue)
{
   int rgb;

   rgb = (red << 16) | (green << 8) | blue;

   // Some palettes have bugs causing the above value to be more than 24 bits
   palettes[current_palette].rgb[ind] = rgb & 0xFFFFFF;
}

#define MIN(x,y) ( (x) < (y) ? (x) : (y) )

int spg(int x)
{
   return ( x < 64 ? x : (127 - x) );
}

// Clean these palette functions up...

void palette_XX(void)
{
   int color,red,blue,green;
   setRGBpalette(0, 0,0,0);
   setRGBpalette(255,63,63,63);

   for (color=1;color!=128;color++)
      {
         red   = 32-(int)(31*(sin((2*color*M_PI)/20.0)*cos((2*color*M_PI)/28.0)));
         green = 32-(int)(31*(cos((2*color*M_PI)/38.0)*cos((2*color*M_PI)/56.0)));
         blue  = 32-(int)(31*(sin((2*color*M_PI)/97.0)*cos((2*color*M_PI)/35.0)));

      setRGBpalette(color, red,green,blue);
      }

   for (color=1;color!=128;color++)
      {
         red   = 32-(int)(31*sin((2*color*M_PI)/128.0));
         green = 32-(int)(31*cos((2*color*M_PI)/128.0));
         blue  = 32-(int)(31*sin((2*color*M_PI)/64.0));

      setRGBpalette(color+127, red,green,blue);
      }
}

#define SCALE(x,a,b,A,B) ( (A) + ( (B)-(A) ) * ( (x)-(a) ) / ( (b) - (a) ) )

#define MKPOS(x) ((x) > 0.0 ? (x) : 0.0 )
double hump(double x)
{
   return (double)MKPOS( (0.75 + cos(x)) / 1.75 );
}

// Palettes 3, 5, 6, 8, 12, and 13 were hardcoded arrays here. Just use existing
// arrays if needed.

void palette_0(void) // was palette 14
{
   int color,red,blue,green;
   setRGBpalette(0, 0,0,0);
   setRGBpalette(255,63,63,63);
   setRGBpalette(254,31,31,31); // bug: below doesn't set 254

   for (color=1;color!=64;color++)
      {
         red   = 32-(int)(31*(sin((4*color*M_PI)/20.0)*cos((4*color*M_PI)/28.0)));
         green = 32-(int)(31*(cos((4*color*M_PI)/38.0)*cos((4*color*M_PI)/56.0)));
         blue  = 32-(int)(31*(sin((4*color*M_PI)/97.0)*cos((4*color*M_PI)/35.0)));

      setRGBpalette(color, red,green,blue);
      setRGBpalette(color+127, red,green,blue);
      }

   for (color=1;color!=64;color++)
      {

         red   = 32-(int)(31*sin((4*color*M_PI)/128.0));
         green = 32-(int)(31*cos((4*color*M_PI)/128.0));
         blue  = 32-(int)(31*sin((4*color*M_PI)/64.0));

      setRGBpalette(color+63, red,green,blue);
      setRGBpalette(color+127+63, red,green,blue);
      }
}

void palette_1(void)
{
   int   i;
   for (i = 0; i < 256; ++i)
   {
      if (i == 0)
         setRGBpalette(i, 0, 0, 0);
      else if (i < 64) {
         setRGBpalette(i, spg((3*i) & 127),
                          spg((5*i) & 127),
                          spg((7*i) & 127));
      }
      else if (i < 128) {
         if (i%2) {
            setRGBpalette(i, spg((32 + 2*i) & 127),
                             spg((32 + 3*i) & 127),
                             spg((32 + 4*i) & 127));
         }
         else
         {
            setRGBpalette(i, spg((10 + 2*i) & 127),
                             spg((32 + 3*i) & 127),
                             spg((32 + 4*i) & 127));
         }
      }
      else if (i < 192) {
         setRGBpalette(i, spg((2*i) & 127),
                          spg((2*i) & 127),
                          spg((3*i) & 127));
      }
      else {
         if (i%2) {
            setRGBpalette(i, spg((45 + 3*i) & 127),
                             spg((45 + 2*i) & 127),
                             spg((45 + 2*i) & 127));
         }
         else
         {
            setRGBpalette(i, spg((45 + 3*i) & 127),
                             spg((20 + 2*i) & 127),
                             spg((45 + 2*i) & 127));
         }
      }
   }
}

void  palette_2(void)
{
   int   i;
   for (i = 0; i < 256; ++i)
   {
      if (i == 0)
         setRGBpalette(i, 0, 0, 0);
      else if (i < 64) {
         setRGBpalette(i, spg((int)(1.3*i) & 127),
                          spg((int)(1.7*i) & 127),
                          spg((int)(1.9*i) & 127));
      }
      else if (i < 128) {
         if (i%2) {
            setRGBpalette(i, spg((int)(1.3*i) & 127),
                             spg((int)(1.7*i) & 127),
                             spg((int)(1.9*i) & 127));
         }
         else
         {
            setRGBpalette(i, spg((-10 + (int)(1.3*i)) & 127),
                             spg((-10 + (int)(1.7*i)) & 127),
                             spg((      (int)(1.9*i)) & 127));
         }
      }
      else if (i < 192) {
         setRGBpalette(i, spg((int)(1.3*i) & 127),
                          spg((int)(1.7*i) & 127),
                          spg((int)(1.9*i) & 127));
      }
      else {
         if (i%2) {
            setRGBpalette(i, spg((     (int)(1.3*i)) & 127),
                             spg((     (int)(1.7*i)) & 127),
                             spg((     (int)(1.9*i)) & 127));
         }
         else
         {
            setRGBpalette(i, spg((      (int)(1.3*i)) & 127),
                             spg((-10 + (int)(1.7*i)) & 127),
                             spg((-10 + (int)(1.9*i)) & 127));
         }
      }
   }
}

void palette_3(void)
{
}

void palette_4(void)
{
   int color,red,blue,green;
   for (color=0;color!=256;color++)
      {

         red   = 32-(int)(31*sin((color*M_PI)/128.0));
         green = 32-(int)(31*cos((color*M_PI)/128.0));
         blue  = 32-(int)(31*sin((color*M_PI)/64.0));

      setRGBpalette(color, red,green,blue);
      }

}

void palette_5(void)
{
}

void palette_6(void)
{
}

void palette_7(void)
{
   int i, gi;
   double g = 10.0;
   double gmax = 40.0;

   double step = 2.0 * (gmax - g) / 64.0;

   for (i = 0; i < 256; i += 4) // had bug: started at 1, ran off end of array
   {
      gi = (int) g;
      setRGBpalette(i, gi, gi, gi);
      setRGBpalette(i + 1, gi, gi, gi);
      setRGBpalette(i + 2, gi, gi, gi);
      setRGBpalette(i + 3, rand() & 255, rand() & 255, rand() & 255 );
      g += step;
   }
}

void palette_8(void)
{
}

/**** Gray Scale Winning ****/
#define MPI 3.14159
#define RATE 0.07
void palette_9(void)
{
   int   i, x;

   i = 0;
   for (x = 0; x < 32; ++x,++i)
      setRGBpalette(i,
         (int)((2.0-0.5*hump(RATE * i  +     0.0))  * x),
         (int)((2.0-0.5*hump(RATE * i  + 2*MPI/3))  * x),
         (int)((2.0-0.5*hump(RATE * i  + 4*MPI/3))  * x));
   for (x = 31; x >= 0; --x,++i)
      setRGBpalette(i,
         (int)((2.0-0.3*hump(RATE * i  +     0.0))  * x),
         (int)((2.0-0.3*hump(RATE * i  + 2*MPI/3))  * x),
         (int)((2.0-0.3*hump(RATE * i  + 4*MPI/3))  * x));

   for (x = 0; x < 32; ++x,++i)
      setRGBpalette(i,
         (int)((2.0-0.5*hump(RATE * i  +     0.0))  * x),
         (int)((2.0-0.5*hump(RATE * i  + 2*MPI/3))  * x),
         (int)((2.0-0.5*hump(RATE * i  + 4*MPI/3))  * x));
   for (x = 31; x >= 0; --x,++i)
      setRGBpalette(i,
         (int)((2.0-0.3*hump(RATE * i  +     0.0))  * x),
         (int)((2.0-0.3*hump(RATE * i  + 2*MPI/3))  * x),
         (int)((2.0-0.3*hump(RATE * i  + 4*MPI/3))  * x));

   for (x = 0; x < 32; ++x,++i)
      setRGBpalette(i,
         (int)((2.0-0.5*hump(RATE * i  +     0.0))  * x),
         (int)((2.0-0.5*hump(RATE * i  + 2*MPI/3))  * x),
         (int)((2.0-0.5*hump(RATE * i  + 4*MPI/3))  * x));
   for (x = 31; x >= 0; --x,++i)
      setRGBpalette(i,
         (int)((2.0-0.3*hump(RATE * i  +     0.0))  * x),
         (int)((2.0-0.3*hump(RATE * i  + 2*MPI/3))  * x),
         (int)((2.0-0.3*hump(RATE * i  + 4*MPI/3))  * x));

   for (x = 0; x < 32; ++x,++i)
      setRGBpalette(i,
         (int)((2.0-0.5*hump(RATE * i  +     0.0))  * x),
         (int)((2.0-0.5*hump(RATE * i  + 2*MPI/3))  * x),
         (int)((2.0-0.5*hump(RATE * i  + 4*MPI/3))  * x));
   for (x = 31; x >= 0; --x,++i)
      setRGBpalette(i,
         (int)((2.0-0.3*hump(RATE * i  +     0.0))  * x),
         (int)((2.0-0.3*hump(RATE * i  + 2*MPI/3))  * x),
         (int)((2.0-0.3*hump(RATE * i  + 4*MPI/3))  * x));

   setRGBpalette(0, 0, 0, 0);
}

/***** Angry Palette *****/
void  palette_10(void)
{
   int cnum[] = {  0,  32,  64,  96, 128, 160, 192, 224, 256, -1};
   int red[]  = {  0,  63,  63,  63,   0,  63,  63,  63,   0};
   int green[]= {  0,   0,  63,  48,   0,  32,  63,  48,   0};
   int blue[] = {  0,   0,  63,   0,   0,   0,  63,   0,   0};
   int   i,x;

   setRGBpalette(0, 0, 0, 0);
   for (i = 1; i < 256; ++i) {
      for (x = 0; cnum[x] != -1; ++x)
         if (i <= cnum[x]) {
            setRGBpalette(i,
               (int)SCALE((double)i, (double)cnum[x-1], (double)cnum[x],   (double)red[x-1], (double)red[x]),
               (int)SCALE((double)i, (double)cnum[x-1], (double)cnum[x], (double)green[x-1], (double)green[x]),
               (int)SCALE((double)i, (double)cnum[x-1], (double)cnum[x],  (double)blue[x-1], (double)blue[x]));
            break;
         }
   }
}

void palette_11(void)
{
   int color,red,blue,green;
   setRGBpalette(0, 0,0,0);
   setRGBpalette(255,63,63,63);

   for (color=1;color!=255;color++)
      {
         red   = 32-(int)(31*(sin((color*M_PI)/61.0)*cos((color*M_PI)/47.0)*cos((color*M_PI)/37.0)));
         green = 32-(int)(31*(cos((color*M_PI)/79.0)*cos((color*M_PI)/29.0)*cos((color*M_PI)/107.0)));
         blue  = 32-(int)(31*(sin((color*M_PI)/87.0)*cos((color*M_PI)/23.0)*sin((color*M_PI)/53.0)));

      setRGBpalette(color, red,green,blue);
      }
}

void palette_12(void)
{
}

void palette_13(void)
{
}

void scroll_palette(int direction)
{
   // implement this
}

void set_all_colors(void *memory)
{
   // implement this
}

// Modify palettes to start from 0, not 1

void dump_palettes(void)
{
   int i, j, size;
   FILE *fp;

   if ( (fp = fopen("palarray.txt", "wt")) == NULL)
      return;

   for (i = 0; i < NUM_PALETTES; i++)
   {
      fprintf(fp, "unsigned pal_%d[] = \n{\n", i);
      size = palettes[i].size;
      for(j = 0; j < size; j++)
      {
         fprintf(fp, "0x%06X, ", palettes[i].rgb[j]);
         if ((j & 7) == 7) // 8 entries/line
            fprintf(fp, "\n");
      }
      fprintf(fp, "};\n");
   }
   fclose(fp);
}

// This would now need updating (see other init_palettes())
int init_palettes(void)
{
   int i, j, size;
   palette *p;

   p = palettes;
   for (i = 0; i < NUM_PALETTES; i++)
   {
      size = p[i].size;
      if ((p[i].rgb = (unsigned *) malloc(size * sizeof(unsigned))) == NULL)
      {
         MessageBox(NULL, "Error allocating palettes.", NULL, MB_OK | MB_ICONSTOP);
         exit(1);
      }

      current_palette = i;

      switch (i)
      {
         case 0 : palette_0();break;
         case 1 : palette_1();break;
         case 2 : palette_2();break;
         case 3 : palette_3();break;
         case 4 : palette_4();break;
         case 5 : palette_5();break;
         case 6 : palette_6();break;
         case 7 : palette_7();break;
         case 8 : palette_8();break;
         case 9 : palette_9();break;
         case 10 : palette_10();break;
         case 11 : palette_11();break;
         case 12 : palette_12();break;
         case 13 : palette_13();break;
         case 14 : // do grayscale here
      }

      // For some reason, old palettes limited color components to a max of 63. Change
      // to full range (0 - 255).

      for (j = 0; j < size; j++)
         p[i].rgb[j] = (p[i].rgb[j] <<= 2) & 0xFFFFFF;
   }
   dump_palettes(); // dump to arrays so we don't need to run the generation code every time
   return NUM_PALETTES;
}

#else // #ifdef PAL_GENERATE

// Use arrays, generated by code above

unsigned pal_0[] =
{
0x000000, 0x401074, 0x38286C, 0x684C6C, 0x907078, 0x808490, 0x4088AC, 0x0C80CC,
0x1868E4, 0x544CF0, 0x8034E8, 0x702CD4, 0x3838B0, 0x185084, 0x38785C, 0x809C38,
0xACBC24, 0x98CC20, 0x68C828, 0x54B440, 0x809858, 0xC88074, 0xE87480, 0xC87484,
0x908480, 0x80A478, 0xACC868, 0xE8E858, 0xF4F854, 0xC0F45C, 0x80E070, 0x70C08C,
0x989CB0, 0xC884D4, 0xC07CEC, 0x8080F8, 0x4094F0, 0x38B0DC, 0x68CCB8, 0x90D88C,
0x80D868, 0x40C048, 0x0C9C38, 0x187834, 0x545440, 0x804050, 0x704068, 0x384C78,
0x186880, 0x388080, 0x809074, 0xAC9460, 0x98844C, 0x686C40, 0x54443C, 0x802448,
0xC80C64, 0xE80884, 0xC818AC, 0x9034D0, 0x8058EC, 0xAC74F8, 0xE880F4, 0xF480DC,
0x740868, 0x680854, 0x600C3C, 0x54102C, 0x48141C, 0x3C1C10, 0x342408, 0x2C2C04,
0x243408, 0x1C3C10, 0x14481C, 0x10542C, 0x0C603C, 0x086854, 0x087468, 0x048080,
0x088C98, 0x0898AC, 0x0CA0C4, 0x10ACD4, 0x14B8E4, 0x1CC4F0, 0x24CCF8, 0x2CD4FC,
0x34DCF8, 0x3CE4F0, 0x48ECE4, 0x54F0D4, 0x60F4C4, 0x68F8AC, 0x74F898, 0x80FC80,
0x8CF868, 0x98F854, 0xA0F43C, 0xACF02C, 0xB8EC1C, 0xC4E410, 0xCCDC08, 0xD4D404,
0xDCCC08, 0xE4C410, 0xECB81C, 0xF0AC2C, 0xF4A03C, 0xF89854, 0xF88C68, 0xFC8080,
0xF87498, 0xF868AC, 0xF460C4, 0xF054D4, 0xEC48E4, 0xE43CF0, 0xDC34F8, 0xD42CFC,
0xCC24F8, 0xC41CF0, 0xB814E4, 0xAC10D4, 0xA00CC4, 0x9808AC, 0x8C0898, 0xC1CD70,
0x401074, 0x38286C, 0x684C6C, 0x907078, 0x808490, 0x4088AC, 0x0C80CC, 0x1868E4,
0x544CF0, 0x8034E8, 0x702CD4, 0x3838B0, 0x185084, 0x38785C, 0x809C38, 0xACBC24,
0x98CC20, 0x68C828, 0x54B440, 0x809858, 0xC88074, 0xE87480, 0xC87484, 0x908480,
0x80A478, 0xACC868, 0xE8E858, 0xF4F854, 0xC0F45C, 0x80E070, 0x70C08C, 0x989CB0,
0xC884D4, 0xC07CEC, 0x8080F8, 0x4094F0, 0x38B0DC, 0x68CCB8, 0x90D88C, 0x80D868,
0x40C048, 0x0C9C38, 0x187834, 0x545440, 0x804050, 0x704068, 0x384C78, 0x186880,
0x388080, 0x809074, 0xAC9460, 0x98844C, 0x686C40, 0x54443C, 0x802448, 0xC80C64,
0xE80884, 0xC818AC, 0x9034D0, 0x8058EC, 0xAC74F8, 0xE880F4, 0xF480DC, 0x740868,
0x680854, 0x600C3C, 0x54102C, 0x48141C, 0x3C1C10, 0x342408, 0x2C2C04, 0x243408,
0x1C3C10, 0x14481C, 0x10542C, 0x0C603C, 0x086854, 0x087468, 0x048080, 0x088C98,
0x0898AC, 0x0CA0C4, 0x10ACD4, 0x14B8E4, 0x1CC4F0, 0x24CCF8, 0x2CD4FC, 0x34DCF8,
0x3CE4F0, 0x48ECE4, 0x54F0D4, 0x60F4C4, 0x68F8AC, 0x74F898, 0x80FC80, 0x8CF868,
0x98F854, 0xA0F43C, 0xACF02C, 0xB8EC1C, 0xC4E410, 0xCCDC08, 0xD4D404, 0xDCCC08,
0xE4C410, 0xECB81C, 0xF0AC2C, 0xF4A03C, 0xF89854, 0xF88C68, 0xFC8080, 0xF87498,
0xF868AC, 0xF460C4, 0xF054D4, 0xEC48E4, 0xE43CF0, 0xDC34F8, 0xD42CFC, 0xCC24F8,
0xC41CF0, 0xB814E4, 0xAC10D4, 0xA00CC4, 0x9808AC, 0x8C0898, 0x7C7C7C, 0xFCFCFC,
};
unsigned pal_1[] =
{
0x000000, 0x0C141C, 0x182838, 0x243C54, 0x305070, 0x3C648C, 0x4878A8, 0x548CC4,
0x60A0E0, 0x6CB4FC, 0x78C8E4, 0x84DCC8, 0x90F0AC, 0x9CF890, 0xA8E474, 0xB4D058,
0xC0BC3C, 0xCCA820, 0xD89404, 0xE48014, 0xF06C30, 0xFC584C, 0xF44468, 0xE83084,
0xDC1CA0, 0xD008BC, 0xC408D8, 0xB81CF4, 0xAC30EC, 0xA044D0, 0x9458B4, 0x886C98,
0x7C807C, 0x709460, 0x64A844, 0x58BC28, 0x4CD00C, 0x40E40C, 0x34F828, 0x28F044,
0x1CDC60, 0x10C87C, 0x04B498, 0x04A0B4, 0x108CD0, 0x1C78EC, 0x2864F4, 0x3450D8,
0x403CBC, 0x4C28A0, 0x581484, 0x640068, 0x70104C, 0x7C2430, 0x883814, 0x944C04,
0xA06020, 0xAC743C, 0xB88858, 0xC49C74, 0xD0B090, 0xDCC4AC, 0xE8D8C8, 0xF4ECE4,
0x287C80, 0x887090, 0x3864A0, 0x9858B0, 0x484CC0, 0xA840D0, 0x5834E0, 0xB828F0,
0x681CFC, 0xC810EC, 0x7804DC, 0xD804CC, 0x8810BC, 0xE81CAC, 0x98289C, 0xF8348C,
0xA8407C, 0xF44C6C, 0xB8585C, 0xE4644C, 0xC8703C, 0xD47C2C, 0xD8881C, 0xC4940C,
0xE8A000, 0xB4AC10, 0xF8B820, 0xA4C430, 0xF4D040, 0x94DC50, 0xE4E860, 0x84F470,
0xD4FC80, 0x74F090, 0xC4E4A0, 0x64D8B0, 0xB4CCC0, 0x54C0D0, 0xA4B4E0, 0x44A8F0,
0x949CFC, 0x3490EC, 0x8484DC, 0x2478CC, 0x746CBC, 0x1460AC, 0x64549C, 0x04488C,
0x543C7C, 0x08306C, 0x44245C, 0x18184C, 0x340C3C, 0x28002C, 0x24081C, 0x38140C,
0x142000, 0x482C10, 0x043820, 0x584430, 0x085040, 0x685C50, 0x186860, 0x787470,
0x000000, 0x08080C, 0x101018, 0x181824, 0x202030, 0x28283C, 0x303048, 0x383854,
0x404060, 0x48486C, 0x505078, 0x585884, 0x606090, 0x68689C, 0x7070A8, 0x7878B4,
0x8080C0, 0x8888CC, 0x9090D8, 0x9898E4, 0xA0A0F0, 0xA8A8FC, 0xB0B0F4, 0xB8B8E8,
0xC0C0DC, 0xC8C8D0, 0xD0D0C4, 0xD8D8B8, 0xE0E0AC, 0xE8E8A0, 0xF0F094, 0xF8F888,
0xFCFC7C, 0xF4F470, 0xECEC64, 0xE4E458, 0xDCDC4C, 0xD4D440, 0xCCCC34, 0xC4C428,
0xBCBC1C, 0xB4B410, 0xACAC04, 0xA4A404, 0x9C9C10, 0x94941C, 0x8C8C28, 0x848434,
0x7C7C40, 0x74744C, 0x6C6C58, 0x646464, 0x5C5C70, 0x54547C, 0x4C4C88, 0x444494,
0x3C3CA0, 0x3434AC, 0x2C2CB8, 0x2424C4, 0x1C1CD0, 0x1414DC, 0x0C0CE8, 0x0404F4,
0x4850B4, 0x3CBCBC, 0x3060C4, 0x24CCCC, 0x1870D4, 0x0CDCDC, 0x0080E4, 0x08ECEC,
0x1490F4, 0x20FCFC, 0x2CA0F8, 0x38F0F0, 0x44B0E8, 0x50E0E0, 0x5CC0D8, 0x68D0D0,
0x74D0C8, 0x80C0C0, 0x8CE0B8, 0x98B0B0, 0xA4F0A8, 0xB0A0A0, 0xBCFC98, 0xC89090,
0xD4EC88, 0xE08080, 0xECDC78, 0xF87070, 0xF8CC68, 0xEC6060, 0xE0BC58, 0xD45050,
0xC8AC48, 0xBC4040, 0xB09C38, 0xA43030, 0x988C28, 0x8C2020, 0x807C18, 0x741010,
0x686C08, 0x5C0000, 0x505C04, 0x440C0C, 0x384C14, 0x2C1C1C, 0x203C24, 0x142C2C,
0x082C34, 0x003C3C, 0x0C1C44, 0x184C4C, 0x240C54, 0x305C5C, 0x3C0064, 0x486C6C,
0x541074, 0x607C7C, 0x6C2084, 0x788C8C, 0x843094, 0x909C9C, 0x9C40A4, 0xA8ACAC,
};
unsigned pal_2[] =
{
0x000000, 0x040404, 0x080C0C, 0x0C1414, 0x14181C, 0x182024, 0x1C282C, 0x242C34,
0x28343C, 0x2C3C44, 0x34444C, 0x384850, 0x3C5058, 0x405860, 0x485C68, 0x4C6470,
0x506C78, 0x587080, 0x5C7888, 0x608090, 0x688898, 0x6C8C9C, 0x7094A4, 0x749CAC,
0x7CA0B4, 0x80A8BC, 0x84B0C4, 0x8CB4CC, 0x90BCD4, 0x94C4DC, 0x9CCCE4, 0xA0D0E8,
0xA4D8F0, 0xA8E0F8, 0xB0E4FC, 0xB4ECF4, 0xB8F4EC, 0xC0F8E4, 0xC4FCDC, 0xC8F4D4,
0xD0ECCC, 0xD4E8C8, 0xD8E0C0, 0xDCD8B8, 0xE4D4B0, 0xE8CCA8, 0xECC4A0, 0xF4C098,
0xF8B890, 0xFCB088, 0xF8A880, 0xF4A47C, 0xF09C74, 0xEC946C, 0xE49064, 0xE0885C,
0xDC8054, 0xD47C4C, 0xD07444, 0xCC6C3C, 0xC46434, 0xC06030, 0xBC5828, 0xB85020,
0xD87418, 0xAC4410, 0xD06408, 0xA03800, 0xC45804, 0x98280C, 0xB84814, 0x8C1C18,
0xB03C20, 0x840C28, 0xA43030, 0x780038, 0x9C2040, 0x6C0848, 0x901450, 0x641858,
0x840460, 0x582464, 0x7C046C, 0x503474, 0x70107C, 0x444084, 0x68208C, 0x384C94,
0x5C2C9C, 0x305CA4, 0x503CAC, 0x2468B0, 0x4848B8, 0x1C78C0, 0x3C54C8, 0x1084D0,
0x3464D8, 0x0490E0, 0x2870E8, 0x00A0F0, 0x1C80F8, 0x0CACFC, 0x148CF8, 0x14BCF0,
0x0898E8, 0x20C8E0, 0x00A8D8, 0x2CD4D0, 0x08B4C8, 0x34E4C0, 0x14C4B8, 0x40F0B4,
0x1CD0AC, 0x48FCA4, 0x28DC9C, 0x54F094, 0x30EC8C, 0x60E484, 0x3CF87C, 0x68D474,
0x48F46C, 0x74C868, 0x50E860, 0x7CB858, 0x5CDC50, 0x88AC48, 0x64CC40, 0x94A038,
0x989830, 0x9C9028, 0xA48820, 0xA8841C, 0xAC7C14, 0xB0740C, 0xB87004, 0xBC6800,
0xC06008, 0xC85C10, 0xCC5418, 0xD04C20, 0xD84428, 0xDC402C, 0xE03834, 0xE4303C,
0xEC2C44, 0xF0244C, 0xF41C54, 0xFC185C, 0xFC1064, 0xF8086C, 0xF00074, 0xEC0078,
0xE80880, 0xE41088, 0xDC1490, 0xD81C98, 0xD424A0, 0xCC28A8, 0xC830B0, 0xC438B8,
0xBC40C0, 0xB844C4, 0xB44CCC, 0xB054D4, 0xA858DC, 0xA460E4, 0xA068EC, 0x986CF4,
0x9474FC, 0x907CF8, 0x8884F0, 0x8488EC, 0x8090E4, 0x7C98DC, 0x749CD4, 0x70A4CC,
0x6CACC4, 0x64B0BC, 0x60B8B4, 0x5CC0AC, 0x54C8A4, 0x50CCA0, 0x4CD498, 0x48DC90,
0x40E088, 0x3CE880, 0x38F078, 0x30F470, 0x2CFC68, 0x28F860, 0x20F058, 0x1CEC54,
0x18F074, 0x14DC44, 0x0CFC64, 0x08D034, 0x04F054, 0x00C424, 0x04E444, 0x08B414,
0x10D434, 0x14A808, 0x18C828, 0x1C9804, 0x24BC18, 0x288C14, 0x2CAC08, 0x348024,
0x38A004, 0x3C7034, 0x449014, 0x486440, 0x4C8420, 0x505450, 0x587830, 0x5C4860,
0x606840, 0x683C70, 0x6C5C50, 0x702C80, 0x784C60, 0x7C208C, 0x80406C, 0x84109C,
0x8C347C, 0x9004AC, 0x94248C, 0x9C04BC, 0xA0189C, 0xA414CC, 0xAC08AC, 0xB020D8,
0xB400B8, 0xB830E8, 0xC00CC8, 0xC43CF8, 0xC81CD8, 0xD048F4, 0xD428E8, 0xD858E4,
0xE038F8, 0xE464D8, 0xE844F8, 0xEC74C8, 0xF450E8, 0xF880B8, 0xFC60D8, 0xF88CA8,
0xF46CC8, 0xF09C98, 0xE87CB8, 0xE4A88C, 0xE088AC, 0xDCB87C, 0xD4949C, 0xD0C46C,
};
unsigned pal_3[] =
{
0x000000, 0x184048, 0x141C54, 0x101850, 0x141C4C, 0x1C204C, 0x242448, 0x2C2848,
0x302C44, 0x383044, 0x403444, 0x483840, 0x4C3C40, 0x54403C, 0x5C443C, 0x58483C,
0x584C40, 0x585040, 0x545444, 0x545844, 0x545C48, 0x50604C, 0x4C6450, 0x486854,
0x446C58, 0x40705C, 0x3C7864, 0x307C6C, 0x347C68, 0x3C8064, 0x448460, 0x488860,
0x508C5C, 0x588C58, 0x609054, 0x649454, 0x6C9850, 0x749C4C, 0x80A048, 0x8CA448,
0x98A844, 0xA4AC44, 0xB0B040, 0xBCB440, 0xCCB840, 0xDCBC40, 0xE8C03C, 0xF8C43C,
0xF8C444, 0xF8CC50, 0xF8CC58, 0xF8D468, 0xF4CC64, 0xF4C860, 0xF4C45C, 0xF4C05C,
0xF4BC58, 0xF4B454, 0xF4B050, 0xF4AC50, 0xF4A84C, 0xF4A448, 0xF49C48, 0xF49844,
0xF49440, 0xF4903C, 0xF48C3C, 0xF48438, 0xF48034, 0xF47C34, 0xF47830, 0xF4742C,
0xF46C28, 0xF46828, 0xF46424, 0xF46020, 0xF45C1C, 0xF4541C, 0xF45018, 0xF44C14,
0xF44814, 0xF44410, 0xF43C0C, 0xF43808, 0xF43408, 0xF43004, 0xF42C00, 0xEC2C00,
0xE82C00, 0xE42C04, 0xDC3004, 0xD83008, 0xD43008, 0xCC2C08, 0xC42C08, 0xBC2C08,
0xB42808, 0xAC2808, 0xA42808, 0xA02408, 0x982408, 0x902408, 0x882008, 0x802008,
0x782008, 0x701C08, 0x6C1C08, 0x641808, 0x5C1808, 0x541808, 0x4C1408, 0x441408,
0x3C1408, 0x381408, 0x301008, 0x281008, 0x201008, 0x180C08, 0x18100C, 0x1C1810,
0x1C1C14, 0x1C2018, 0x20241C, 0x202820, 0x243028, 0x242C28, 0x202828, 0x1C2428,
0x182028, 0x141C28, 0x101828, 0x101428, 0x0C1028, 0x080C28, 0x040828, 0x040828,
0x040828, 0x080C28, 0x0C1028, 0x10142C, 0x18182C, 0x1C1C30, 0x202030, 0x282434,
0x2C2838, 0x303038, 0x38343C, 0x3C383C, 0x403C40, 0x484044, 0x4C4444, 0x504848,
0x544C48, 0x5C544C, 0x605850, 0x645C50, 0x6C6054, 0x706454, 0x746858, 0x7C6C58,
0x80705C, 0x887860, 0x8C7C60, 0x908064, 0x988464, 0x9C8868, 0xA08C6C, 0xA8906C,
0xAC9470, 0xB09C70, 0xB8A074, 0xBCA478, 0xC0A878, 0xC8AC7C, 0xCCB07C, 0xD0B480,
0xD8BC84, 0xDCC088, 0xE0C488, 0xE8C88C, 0xECCC8C, 0xECC488, 0xE8C084, 0xE8BC80,
0xE8B880, 0xE8B47C, 0xE4B07C, 0xE4AC78, 0xE4AC78, 0xE4A874, 0xE4A474, 0xE0A070,
0xE09C70, 0xE0986C, 0xE0946C, 0xDC9468, 0xDC9068, 0xDC8C64, 0xDC8864, 0xDC8460,
0xD88060, 0xD8805C, 0xD87C5C, 0xD87858, 0xD87454, 0xD47054, 0xD46C50, 0xD46850,
0xD4684C, 0xD0644C, 0xD06048, 0xD05C48, 0xD05844, 0xD05444, 0xCC5440, 0xCC5040,
0xCC4C3C, 0xCC483C, 0xC84438, 0xC84038, 0xC83C34, 0xC83C34, 0xC83830, 0xC43430,
0xC4302C, 0xBC2C28, 0xB82C28, 0xB42C28, 0xB02C28, 0xAC2C28, 0xA82C28, 0xA42C28,
0x9C2C28, 0x982C28, 0x942C28, 0x902C28, 0x8C2828, 0x882828, 0x842828, 0x802828,
0x782828, 0x742828, 0x702828, 0x6C2828, 0x682828, 0x642828, 0x602828, 0x5C2828,
0x543028, 0x4C342C, 0x3C3828, 0x304024, 0x244820, 0x205820, 0x1C6814, 0x288834,
};
unsigned pal_4[] =
{
0x000000, 0x80087C, 0x7C0874, 0x780870, 0x740868, 0x740864, 0x700860, 0x6C0858,
0x680854, 0x68084C, 0x640848, 0x600C44, 0x600C3C, 0x5C0C38, 0x580C34, 0x541030,
0x54102C, 0x501028, 0x4C1024, 0x4C1420, 0x48141C, 0x441818, 0x441814, 0x401810,
0x3C1C10, 0x3C1C0C, 0x38200C, 0x342008, 0x342408, 0x302408, 0x302808, 0x2C2808,
0x2C2C04, 0x282C08, 0x283008, 0x243008, 0x243408, 0x203408, 0x20380C, 0x1C3C0C,
0x1C3C10, 0x184010, 0x184414, 0x184418, 0x14481C, 0x144C20, 0x104C24, 0x105028,
0x10542C, 0x105430, 0x0C5834, 0x0C5C38, 0x0C603C, 0x0C6044, 0x086448, 0x08684C,
0x086854, 0x086C58, 0x087060, 0x087464, 0x087468, 0x087870, 0x087C74, 0x08807C,
0x048080, 0x088084, 0x08848C, 0x088890, 0x088C98, 0x088C9C, 0x0890A0, 0x0894A8,
0x0898AC, 0x0898B4, 0x089CB8, 0x0CA0BC, 0x0CA0C4, 0x0CA4C8, 0x0CA8CC, 0x10ACD0,
0x10ACD4, 0x10B0D8, 0x10B4DC, 0x14B4E0, 0x14B8E4, 0x18BCE8, 0x18BCEC, 0x18C0F0,
0x1CC4F0, 0x1CC4F4, 0x20C8F4, 0x20CCF8, 0x24CCF8, 0x24D0F8, 0x28D0F8, 0x28D4F8,
0x2CD4FC, 0x2CD8F8, 0x30D8F8, 0x30DCF8, 0x34DCF8, 0x34E0F8, 0x38E0F4, 0x3CE4F4,
0x3CE4F0, 0x40E8F0, 0x44E8EC, 0x44E8E8, 0x48ECE4, 0x4CECE0, 0x4CF0DC, 0x50F0D8,
0x54F0D4, 0x54F0D0, 0x58F4CC, 0x5CF4C8, 0x60F4C4, 0x60F4BC, 0x64F8B8, 0x68F8B4,
0x68F8AC, 0x6CF8A8, 0x70F8A0, 0x74F89C, 0x74F898, 0x78F890, 0x7CF88C, 0x80F884,
0x80FC80, 0x80F87C, 0x84F874, 0x88F870, 0x8CF868, 0x8CF864, 0x90F860, 0x94F858,
0x98F854, 0x98F84C, 0x9CF848, 0xA0F444, 0xA0F43C, 0xA4F438, 0xA8F434, 0xACF030,
0xACF02C, 0xB0F028, 0xB4F024, 0xB4EC20, 0xB8EC1C, 0xBCE818, 0xBCE814, 0xC0E810,
0xC4E410, 0xC4E40C, 0xC8E00C, 0xCCE008, 0xCCDC08, 0xD0DC08, 0xD0D808, 0xD4D808,
0xD4D404, 0xD8D408, 0xD8D008, 0xDCD008, 0xDCCC08, 0xE0CC08, 0xE0C80C, 0xE4C40C,
0xE4C410, 0xE8C010, 0xE8BC14, 0xE8BC18, 0xECB81C, 0xECB420, 0xF0B424, 0xF0B028,
0xF0AC2C, 0xF0AC30, 0xF4A834, 0xF4A438, 0xF4A03C, 0xF4A044, 0xF89C48, 0xF8984C,
0xF89854, 0xF89458, 0xF89060, 0xF88C64, 0xF88C68, 0xF88870, 0xF88474, 0xF8807C,
0xFC8080, 0xF88084, 0xF87C8C, 0xF87890, 0xF87498, 0xF8749C, 0xF870A0, 0xF86CA8,
0xF868AC, 0xF868B4, 0xF864B8, 0xF460BC, 0xF460C4, 0xF45CC8, 0xF458CC, 0xF054D0,
0xF054D4, 0xF050D8, 0xF04CDC, 0xEC4CE0, 0xEC48E4, 0xE844E8, 0xE844EC, 0xE840F0,
0xE43CF0, 0xE43CF4, 0xE038F4, 0xE034F8, 0xDC34F8, 0xDC30F8, 0xD830F8, 0xD82CF8,
0xD42CFC, 0xD428F8, 0xD028F8, 0xD024F8, 0xCC24F8, 0xCC20F8, 0xC820F4, 0xC41CF4,
0xC41CF0, 0xC018F0, 0xBC18EC, 0xBC18E8, 0xB814E4, 0xB414E0, 0xB410DC, 0xB010D8,
0xAC10D4, 0xAC10D0, 0xA80CCC, 0xA40CC8, 0xA00CC4, 0xA00CBC, 0x9C08B8, 0x9808B4,
0x9808AC, 0x9408A8, 0x9008A0, 0x8C089C, 0x8C0898, 0x880890, 0x84088C, 0x800884,
};
unsigned pal_5[] =
{
0x000000, 0x080000, 0x000800, 0x000008, 0x100000, 0x080008, 0x080800, 0x100008,
0x100800, 0x180000, 0x180800, 0x101000, 0x180008, 0x200000, 0x181000, 0x200800,
0x180808, 0x280000, 0x300000, 0x280800, 0x380000, 0x281000, 0x280808, 0x281800,
0x301000, 0x301008, 0x281808, 0x400800, 0x381000, 0x381008, 0x381800, 0x281810,
0x381808, 0x401800, 0x382000, 0x500800, 0x382800, 0x481800, 0x402000, 0x401810,
0x501800, 0x381818, 0x481810, 0x581800, 0x482800, 0x302818, 0x502800, 0x402810,
0x601800, 0x502808, 0x501818, 0x582800, 0x402818, 0x582808, 0x402820, 0x601810,
0x602800, 0x502818, 0x682800, 0x503808, 0x403818, 0x603800, 0x602810, 0x684000,
0x603810, 0x602820, 0x782010, 0x604008, 0x503820, 0x683808, 0x783800, 0x504020,
0x604018, 0x684808, 0x603820, 0x783010, 0x584828, 0x882818, 0x783818, 0x604028,
0x685018, 0x505030, 0x784810, 0x785010, 0x783830, 0x883820, 0x684830, 0x785818,
0x942830, 0x943820, 0x885018, 0xAC3810, 0x9C3028, 0x784838, 0x785030, 0x685838,
0x945018, 0x685048, 0x786028, 0x806020, 0x686040, 0x9C5020, 0x786830, 0x884840,
0x806030, 0x785050, 0x886828, 0xA45028, 0x885048, 0x944848, 0xB45020, 0x886838,
0x9C6828, 0x945048, 0x806848, 0x806050, 0x9C6038, 0x9C5050, 0xA46830, 0xA46040,
0x946848, 0x946050, 0x9C6840, 0x887848, 0x806860, 0x9C6058, 0xA46848, 0x9C6850,
0xAC6840, 0xA47840, 0xA47048, 0xA46058, 0xA48040, 0x946868, 0x948050, 0x9C7850,
0xB46848, 0xAC6060, 0xA47058, 0x9C6868, 0xB47840, 0xA48050, 0xAC7058, 0xA47858,
0x9C7068, 0xAC7858, 0x947870, 0xA47068, 0xB47850, 0xAC8050, 0xAC7068, 0xBC7850,
0xA47868, 0xA47070, 0xC47848, 0xA48858, 0xAC7868, 0xB48850, 0x9C8070, 0xB48058,
0xC48848, 0xAC7870, 0xBC8850, 0xB47868, 0x9C8870, 0xAC8068, 0xB48860, 0xB48068,
0xAC8070, 0xBC7868, 0xAC7878, 0xAC8868, 0xB48070, 0xAC8078, 0xC48858, 0xB48868,
0xAC9468, 0xBC9458, 0xAC8878, 0xBC8868, 0xB48870, 0xB48078, 0xAC9C68, 0xB49468,
0xBC9C58, 0xB48878, 0xBC8870, 0xB49470, 0xC49C58, 0xBC9468, 0xAC9478, 0xBC9470,
0xBC9C68, 0xB49478, 0xC49468, 0xCC9C58, 0xB49480, 0xC4A460, 0xBCA468, 0xC49C68,
0xBC9478, 0xBC9C70, 0xAC9C80, 0xC49470, 0xC49C70, 0xD49C60, 0xCCA460, 0xBC9C78,
0xBCAC70, 0xBC9C80, 0xCC9C70, 0xCCAC60, 0xC4A470, 0xC49C78, 0xBC9C88, 0xD49C70,
0xCCAC70, 0xCC9C80, 0xC49C88, 0xCCB470, 0xCCAC78, 0xD4AC70, 0xD4B470, 0xD4AC78,
0xBCAC94, 0xC4BC80, 0xD4BC70, 0xDCB470, 0xDCBC68, 0xD4BC78, 0xD4AC88, 0xCCAC94,
0xDCBC78, 0xD4BC80, 0xD4C478, 0xDCC478, 0xDCC480, 0xD4BC94, 0xCCC494, 0xDCC488,
0xD4CC88, 0xDCCC88, 0xDCC494, 0xDCC4A4, 0xDCCC9C, 0xE4CC94, 0xE4CC9C, 0xDCCCA4,
0xDCD49C, 0xE4CCA4, 0xE4CCAC, 0xDCD4B4, 0xE4D4AC, 0xE4D4B4, 0xE4DCBC, 0xECE4D4,
};
unsigned pal_6[] =
{
0x000000, 0xB8A074, 0xBCA478, 0xC0A878, 0xC8AC7C, 0xCCB07C, 0xD0B480, 0xD8BC84,
0xDCC088, 0xE0C488, 0xE8C88C, 0xECCC8C, 0xECC488, 0xE8C084, 0xE8BC80, 0xE8B880,
0xE8B47C, 0xE4B07C, 0xE4AC78, 0xE4AC78, 0xE4A874, 0xE4A474, 0xE0A070, 0xE09C70,
0xE0986C, 0xE0946C, 0xDC9468, 0xDC9068, 0xDC8C64, 0xDC8864, 0xDC8460, 0xD88060,
0xD8805C, 0xD87C5C, 0xD87858, 0xD87454, 0xD47054, 0xD46C50, 0xD0684C, 0xCC684C,
0xC8684C, 0xC8644C, 0xC4644C, 0xC0644C, 0xC06048, 0xBC6048, 0xB86048, 0xB85C48,
0xB45C48, 0xB05C48, 0xAC5844, 0xAC5844, 0xA85844, 0xA45444, 0xA45444, 0xA05444,
0x9C5040, 0x9C5040, 0x985040, 0x944C40, 0x944C40, 0x904C40, 0x8C483C, 0x88483C,
0x88483C, 0x84443C, 0x80443C, 0x80443C, 0x784038, 0x743C38, 0x6C3C34, 0x683834,
0x643430, 0x5C3430, 0x58302C, 0x542C2C, 0x4C2C28, 0x482828, 0x402824, 0x3C2424,
0x382020, 0x302020, 0x2C1C1C, 0x28181C, 0x201818, 0x1C1418, 0x181418, 0x1C1818,
0x201C1C, 0x24201C, 0x282420, 0x2C2824, 0x302C28, 0x38302C, 0x3C342C, 0x403830,
0x443C34, 0x484038, 0x50443C, 0x50443C, 0x50483C, 0x50483C, 0x504C40, 0x504C40,
0x505040, 0x545444, 0x545844, 0x545C48, 0x50604C, 0x4C6450, 0x486854, 0x446C58,
0x40705C, 0x3C7864, 0x307C6C, 0x347C68, 0x3C8064, 0x448460, 0x488860, 0x508C5C,
0x588C58, 0x609054, 0x649454, 0x6C9850, 0x749C4C, 0x80A048, 0x8CA448, 0x98A844,
0xA4AC44, 0xB0B040, 0xBCB440, 0xCCB840, 0xDCBC40, 0xE8C03C, 0xF8C43C, 0xF8C444,
0xF8CC50, 0xF8CC58, 0xF8D468, 0xF4CC64, 0xF4C860, 0xF4C45C, 0xF4C05C, 0xF4BC58,
0xF4B454, 0xF0B050, 0xECAC50, 0xECA84C, 0xE8A44C, 0xE8A04C, 0xE49C48, 0xE49848,
0xE09448, 0xDC9044, 0xDC8C44, 0xD88844, 0xD88440, 0xD48040, 0xD47C40, 0xD0783C,
0xD0743C, 0xCC703C, 0xC86C38, 0xC86838, 0xC46434, 0xC46034, 0xC05C34, 0xC05830,
0xBC5430, 0xBC5030, 0xB84C2C, 0xB4482C, 0xB4442C, 0xB04028, 0xB03C28, 0xAC3828,
0xAC3424, 0xA83024, 0xA02C24, 0x982C28, 0x942C28, 0x8C282C, 0x88282C, 0x802830,
0x7C2430, 0x742434, 0x702438, 0x6C2434, 0x682434, 0x642434, 0x602030, 0x5C2030,
0x5C2030, 0x58202C, 0x54202C, 0x50202C, 0x4C2028, 0x4C2028, 0x482028, 0x441C24,
0x401C24, 0x3C1C24, 0x381C20, 0x381C20, 0x341C20, 0x301C1C, 0x2C1C1C, 0x281C1C,
0x281C1C, 0x281C18, 0x281C14, 0x281C14, 0x2C1C18, 0x2C2018, 0x2C201C, 0x30201C,
0x30201C, 0x30201C, 0x342420, 0x342420, 0x342420, 0x382824, 0x382824, 0x3C2C28,
0x3C3028, 0x40302C, 0x40342C, 0x443430, 0x443830, 0x483C34, 0x483C34, 0x4C4038,
0x4C4038, 0x50443C, 0x50483C, 0x544840, 0x544C40, 0x584C44, 0x585044, 0x5C5448,
0x5C5448, 0x60584C, 0x645C50, 0x6C6054, 0x706454, 0x746858, 0x7C6C58, 0x80705C,
0x887860, 0x8C7C60, 0x908064, 0x988464, 0x9C8868, 0xA08C6C, 0xA8906C, 0xAC9470,
};
unsigned pal_7[] =
{
0x000000, 0x282828, 0x282828, 0xF88CA4, 0x282828, 0x282828, 0x282828, 0xB38610,
0x2C2C2C, 0x2C2C2C, 0x2C2C2C, 0x4ABB58, 0x303030, 0x303030, 0x303030, 0xC52640,
0x343434, 0x343434, 0x343434, 0xA6EFC4, 0x383838, 0x383838, 0x383838, 0x9ACFAC,
0x3C3C3C, 0x3C3C3C, 0x3C3C3C, 0x1CF36C, 0x404040, 0x404040, 0x404040, 0x64F830,
0x444444, 0x444444, 0x444444, 0x357890, 0x484848, 0x484848, 0x484848, 0xDC1870,
0x4C4C4C, 0x4C4C4C, 0x4C4C4C, 0xCF791C, 0x505050, 0x505050, 0x505050, 0x213448,
0x545454, 0x545454, 0x545454, 0x2EED0C, 0x585858, 0x585858, 0x585858, 0x0C7E98,
0x5C5C5C, 0x5C5C5C, 0x5C5C5C, 0x25F568, 0x606060, 0x606060, 0x606060, 0x7C94E0,
0x646464, 0x646464, 0x646464, 0x2F5174, 0x646464, 0x646464, 0x646464, 0xD65BF0,
0x686868, 0x686868, 0x686868, 0x4CED14, 0x6C6C6C, 0x6C6C6C, 0x6C6C6C, 0x2A2434,
0x707070, 0x707070, 0x707070, 0xBB6C70, 0x747474, 0x747474, 0x747474, 0x6880C8,
0x787878, 0x787878, 0x787878, 0x03B940, 0x7C7C7C, 0x7C7C7C, 0x7C7C7C, 0xF4D9E0,
0x808080, 0x808080, 0x808080, 0xC92448, 0x848484, 0x848484, 0x848484, 0xF67BD8,
0x888888, 0x888888, 0x888888, 0xB77124, 0x8C8C8C, 0x8C8C8C, 0x8C8C8C, 0xC8513C,
0x909090, 0x909090, 0x909090, 0x990110, 0x949494, 0x949494, 0x949494, 0x11AF40,
0x989898, 0x989898, 0x989898, 0xCADCC0, 0x9C9C9C, 0x9C9C9C, 0x9C9C9C, 0x8A84EC,
0xA0A0A0, 0xA0A0A0, 0xA0A0A0, 0x448BD8, 0xA0A0A0, 0xA0A0A0, 0xA0A0A0, 0x2F8674,
0xA4A4A4, 0xA4A4A4, 0xA4A4A4, 0xC3687C, 0xA8A8A8, 0xA8A8A8, 0xA8A8A8, 0x0A6728,
0xACACAC, 0xACACAC, 0xACACAC, 0x75CAE4, 0xB0B0B0, 0xB0B0B0, 0xB0B0B0, 0x00B124,
0xB4B4B4, 0xB4B4B4, 0xB4B4B4, 0x6715F8, 0xB8B8B8, 0xB8B8B8, 0xB8B8B8, 0x03A754,
0xBCBCBC, 0xBCBCBC, 0xBCBCBC, 0x27AAC8, 0xC0C0C0, 0xC0C0C0, 0xC0C0C0, 0xFD4F30,
0xC4C4C4, 0xC4C4C4, 0xC4C4C4, 0xFF599C, 0xC8C8C8, 0xC8C8C8, 0xC8C8C8, 0xFB5850,
0xCCCCCC, 0xCCCCCC, 0xCCCCCC, 0x3B70B4, 0xD0D0D0, 0xD0D0D0, 0xD0D0D0, 0xBE0D98,
0xD4D4D4, 0xD4D4D4, 0xD4D4D4, 0x85255C, 0xD8D8D8, 0xD8D8D8, 0xD8D8D8, 0x3DA7FC,
0xDCDCDC, 0xDCDCDC, 0xDCDCDC, 0x473584, 0xDCDCDC, 0xDCDCDC, 0xDCDCDC, 0x727478,
0xE0E0E0, 0xE0E0E0, 0xE0E0E0, 0xC9C858, 0xE4E4E4, 0xE4E4E4, 0xE4E4E4, 0xC07798,
0xE8E8E8, 0xE8E8E8, 0xE8E8E8, 0x293E10, 0xECECEC, 0xECECEC, 0xECECEC, 0x5C09DC,
0xF0F0F0, 0xF0F0F0, 0xF0F0F0, 0xB0E7A0, 0xF4F4F4, 0xF4F4F4, 0xF4F4F4, 0x272D4C,
0xF8F8F8, 0xF8F8F8, 0xF8F8F8, 0xCC7848, 0xFCFCFC, 0xFCFCFC, 0xFCFCFC, 0x3279D0,
0x010100, 0x010100, 0x010100, 0x5357D0, 0x050504, 0x050504, 0x050504, 0x93527C,
0x090908, 0x090908, 0x090908, 0xD5F964, 0x0D0D0C, 0x0D0D0C, 0x0D0D0C, 0x88CB3C,
0x111110, 0x111110, 0x111110, 0x3F33D0, 0x151514, 0x151514, 0x151514, 0xB6434C,
};
unsigned pal_8[] =
{
0x000000, 0x288834, 0x1C6814, 0x205820, 0x244820, 0x304024, 0x3C3828, 0x4C342C,
0x583028, 0x682C28, 0x3C2828, 0x842828, 0x0C2828, 0x8C2828, 0x182828, 0x182828,
0xA42828, 0x782828, 0x442828, 0x502828, 0x582828, 0x682828, 0x782828, 0x8C2828,
0x942828, 0x9C2828, 0xA42828, 0xB02828, 0xB82828, 0xC42828, 0xD42828, 0xE02828,
0xE02828, 0xE02C28, 0xE02C2C, 0xE0302C, 0xE0302C, 0xE03430, 0xE43830, 0xE43830,
0xE43C34, 0xE43C34, 0xE44034, 0xE44038, 0xE44438, 0xE8483C, 0xE8483C, 0xE84C3C,
0xE84C40, 0xE85040, 0xE85040, 0xE85444, 0xE85444, 0xEC5844, 0xEC5C48, 0xEC5C48,
0xEC6048, 0xEC604C, 0xEC644C, 0xF06850, 0xF07054, 0xF07458, 0xF07C58, 0xF0805C,
0xF08860, 0xF08C64, 0xF09068, 0xEC986C, 0xEC9C70, 0xECA470, 0xECA874, 0xECAC78,
0xECB47C, 0xECB880, 0xECC084, 0xECC488, 0xECCC8C, 0xE8C88C, 0xE0C488, 0xDCC088,
0xD8BC84, 0xD0B480, 0xCCB07C, 0xC8AC7C, 0xC0A878, 0xBCA478, 0xB8A074, 0xB09C70,
0xAC9470, 0xA8906C, 0xA08C6C, 0x9C8868, 0x988464, 0x908064, 0x8C7C60, 0x887860,
0x80705C, 0x7C6C58, 0x746858, 0x706454, 0x6C6054, 0x645C50, 0x605850, 0x5C544C,
0x544C48, 0x504848, 0x4C4444, 0x484044, 0x403C40, 0x3C383C, 0x38343C, 0x303038,
0x2C2838, 0x282434, 0x202030, 0x1C1C30, 0x18182C, 0x10142C, 0x0C1028, 0x080C28,
0x040828, 0x040828, 0x040828, 0x080C28, 0x0C1028, 0x101428, 0x101828, 0x141C28,
0x182028, 0x1C2428, 0x202828, 0x242C28, 0x243028, 0x283428, 0x2C3828, 0x202C20,
0x182018, 0x0C0C08, 0x100C08, 0x180C08, 0x201008, 0x281008, 0x301008, 0x381408,
0x3C1408, 0x441408, 0x4C1408, 0x541808, 0x5C1808, 0x641808, 0x6C1C08, 0x701C08,
0x782008, 0x802008, 0x882008, 0x902408, 0x982408, 0xA02408, 0xA42808, 0xAC2808,
0xB42808, 0xBC2C08, 0xC42C08, 0xCC2C08, 0xD43008, 0xD83008, 0xDC3004, 0xE42C04,
0xE82C00, 0xEC2C00, 0xF42C00, 0xF43004, 0xF43408, 0xF43808, 0xF43C0C, 0xF44410,
0xF44814, 0xF44C14, 0xF45018, 0xF4541C, 0xF45C1C, 0xF46020, 0xF46424, 0xF46828,
0xF46C28, 0xF4742C, 0xF47830, 0xF47C34, 0xF48034, 0xF48438, 0xF48C3C, 0xF4903C,
0xF49440, 0xF49844, 0xF49C48, 0xF4A448, 0xF4A84C, 0xF4AC50, 0xF4B050, 0xF4B454,
0xF4BC58, 0xF4C05C, 0xF4C45C, 0xF4C860, 0xF4CC64, 0xF8D468, 0xF8CC58, 0xF8CC50,
0xF8C444, 0xF8C43C, 0xF8C434, 0xF8C028, 0xF8C018, 0xF8B810, 0xF8B80C, 0xF8B408,
0xF8B404, 0xF8B004, 0xF8B008, 0xF8A80C, 0xF8A810, 0xF8A418, 0xF8A440, 0xEC9C3C,
0xE4983C, 0xDC943C, 0xD48C3C, 0xCC883C, 0xC48038, 0xBC7C38, 0xB47838, 0xAC7438,
0xA47038, 0x9C6C38, 0x946838, 0x8C6438, 0x886034, 0x805834, 0x785434, 0x705038,
0x684C38, 0x64483C, 0x5C443C, 0x54403C, 0x4C3C40, 0x483840, 0x403444, 0x383044,
0x302C44, 0x2C2848, 0x242448, 0x1C204C, 0x141C4C, 0x101850, 0x141C54, 0x1C1C28,
};
unsigned pal_9[] =
{
0x000000, 0x040404, 0x0C0C0C, 0x101414, 0x181C1C, 0x1C2824, 0x243028, 0x283830,
0x304038, 0x34483C, 0x3C5044, 0x445848, 0x4C6050, 0x506854, 0x58705C, 0x607860,
0x688068, 0x70886C, 0x789070, 0x809878, 0x88A07C, 0x90A880, 0x9CB084, 0xA4B88C,
0xACC090, 0xB4C894, 0xC0CC9C, 0xC8D4A0, 0xD4D8A8, 0xDCE0AC, 0xE4E4B4, 0xF0ECB8,
0xF4ECD0, 0xECE4CC, 0xE4DCC4, 0xE0D4BC, 0xD8C8B8, 0xD0C0B0, 0xC8B8AC, 0xC0B0A4,
0xB8A8A0, 0xB0A098, 0xA89890, 0xA0908C, 0x988884, 0x908080, 0x887878, 0x807070,
0x78686C, 0x706064, 0x68585C, 0x605058, 0x584850, 0x504448, 0x483C44, 0x40343C,
0x342C34, 0x2C282C, 0x242024, 0x1C181C, 0x141414, 0x0C0C0C, 0x040404, 0x000000,
0x000000, 0x040408, 0x0C0C10, 0x141018, 0x1C1820, 0x201C28, 0x282430, 0x2C2C38,
0x343040, 0x3C3848, 0x404050, 0x484858, 0x4C4C60, 0x505468, 0x585C70, 0x5C6478,
0x646C80, 0x687488, 0x6C8090, 0x748898, 0x7890A0, 0x7C98A8, 0x84A0AC, 0x88ACB4,
0x90B4B8, 0x94BCC0, 0x9CC8C8, 0xA0D0CC, 0xA8DCD0, 0xACE4D8, 0xB4ECDC, 0xBCF8E0,
0xD4F8E8, 0xCCF0E0, 0xC8E8D8, 0xC0E0CC, 0xBCD8C4, 0xB4D0BC, 0xACC8B4, 0xA8C0AC,
0xA0B8A4, 0x9CB09C, 0x94A894, 0x90A08C, 0x889884, 0x84907C, 0x7C8874, 0x74806C,
0x707864, 0x687060, 0x606858, 0x586050, 0x545448, 0x4C4C44, 0x44443C, 0x3C3C34,
0x34342C, 0x2C2C28, 0x242420, 0x1C1C18, 0x141414, 0x100C0C, 0x080404, 0x000000,
0x000000, 0x080404, 0x100C0C, 0x181410, 0x201818, 0x282020, 0x302424, 0x382C2C,
0x403034, 0x48383C, 0x503C44, 0x584448, 0x604850, 0x685058, 0x705460, 0x78586C,
0x806074, 0x84647C, 0x8C6C84, 0x94708C, 0x9C7898, 0xA07CA0, 0xA884A8, 0xAC88B0,
0xB490BC, 0xB894C4, 0xC09CCC, 0xC4A4D8, 0xC8A8E0, 0xCCB0E8, 0xD4B8F0, 0xD8C0F8,
0xE0D8F8, 0xD8D0F0, 0xD0CCE8, 0xC8C4E0, 0xC0C0D8, 0xB8B8D0, 0xB0B4C8, 0xA8ACC0,
0xA0A4B8, 0x98A0B0, 0x9098A8, 0x8894A0, 0x808C98, 0x788490, 0x748088, 0x6C787C,
0x647074, 0x5C6C6C, 0x586464, 0x505C5C, 0x485454, 0x444C4C, 0x3C4444, 0x343C3C,
0x2C3434, 0x28302C, 0x202824, 0x18201C, 0x141814, 0x0C100C, 0x040804, 0x000000,
0x000000, 0x040804, 0x0C100C, 0x101810, 0x182018, 0x202820, 0x283024, 0x30382C,
0x344030, 0x3C4834, 0x44503C, 0x4C5840, 0x546048, 0x5C644C, 0x686C54, 0x707458,
0x787C60, 0x808064, 0x88886C, 0x949070, 0x9C9478, 0xA49C7C, 0xACA084, 0xB8A488,
0xC0AC90, 0xC8B098, 0xD0B4A0, 0xD8BCA8, 0xE0C0B0, 0xE8C4B8, 0xF0C8C0, 0xF8CCC8,
0xF8DCDC, 0xF0D4D4, 0xE8CCD0, 0xE0C4C8, 0xD8BCC4, 0xD0B4BC, 0xC8ACB8, 0xC0A4B0,
0xB89CAC, 0xB094A4, 0xA88C9C, 0x9C8898, 0x948090, 0x8C7888, 0x847084, 0x7C6C7C,
0x746474, 0x6C5C6C, 0x645864, 0x5C505C, 0x504858, 0x484450, 0x403C48, 0x383440,
0x343038, 0x2C2830, 0x242028, 0x1C1C20, 0x141418, 0x0C0C10, 0x040408, 0x000000,
};
unsigned pal_10[] =
{
0x000000, 0x040000, 0x0C0000, 0x140000, 0x1C0000, 0x240000, 0x2C0000, 0x340000,
0x3C0000, 0x440000, 0x4C0000, 0x540000, 0x5C0000, 0x640000, 0x6C0000, 0x740000,
0x7C0000, 0x840000, 0x8C0000, 0x940000, 0x9C0000, 0xA40000, 0xAC0000, 0xB40000,
0xBC0000, 0xC40000, 0xCC0000, 0xD40000, 0xDC0000, 0xE40000, 0xEC0000, 0xF40000,
0xFC0000, 0xFC0404, 0xFC0C0C, 0xFC1414, 0xFC1C1C, 0xFC2424, 0xFC2C2C, 0xFC3434,
0xFC3C3C, 0xFC4444, 0xFC4C4C, 0xFC5454, 0xFC5C5C, 0xFC6464, 0xFC6C6C, 0xFC7474,
0xFC7C7C, 0xFC8484, 0xFC8C8C, 0xFC9494, 0xFC9C9C, 0xFCA4A4, 0xFCACAC, 0xFCB4B4,
0xFCBCBC, 0xFCC4C4, 0xFCCCCC, 0xFCD4D4, 0xFCDCDC, 0xFCE4E4, 0xFCECEC, 0xFCF4F4,
0xFCFCFC, 0xFCF8F4, 0xFCF8EC, 0xFCF4E4, 0xFCF4DC, 0xFCF0D4, 0xFCF0CC, 0xFCECC4,
0xFCECBC, 0xFCE8B4, 0xFCE8AC, 0xFCE4A4, 0xFCE49C, 0xFCE094, 0xFCE08C, 0xFCDC84,
0xFCDC7C, 0xFCDC74, 0xFCD86C, 0xFCD864, 0xFCD45C, 0xFCD454, 0xFCD04C, 0xFCD044,
0xFCCC3C, 0xFCCC34, 0xFCC82C, 0xFCC824, 0xFCC41C, 0xFCC414, 0xFCC00C, 0xFCC004,
0xFCC000, 0xF4B800, 0xECB400, 0xE4AC00, 0xDCA800, 0xD4A000, 0xCC9C00, 0xC49400,
0xBC9000, 0xB48800, 0xAC8400, 0xA47C00, 0x9C7800, 0x947000, 0x8C6C00, 0x846400,
0x7C6000, 0x745800, 0x6C5400, 0x644C00, 0x5C4800, 0x544000, 0x4C3C00, 0x443400,
0x3C3000, 0x342800, 0x2C2400, 0x241C00, 0x1C1800, 0x141000, 0x0C0C00, 0x040400,
0x000000, 0x040400, 0x0C0800, 0x140C00, 0x1C1000, 0x241400, 0x2C1800, 0x341C00,
0x3C2000, 0x442400, 0x4C2800, 0x542C00, 0x5C3000, 0x643400, 0x6C3800, 0x743C00,
0x7C4000, 0x844400, 0x8C4800, 0x944C00, 0x9C5000, 0xA45400, 0xAC5800, 0xB45C00,
0xBC6000, 0xC46400, 0xCC6800, 0xD46C00, 0xDC7000, 0xE47400, 0xEC7800, 0xF47C00,
0xFC8000, 0xFC8004, 0xFC840C, 0xFC8814, 0xFC8C1C, 0xFC9024, 0xFC942C, 0xFC9834,
0xFC9C3C, 0xFCA044, 0xFCA44C, 0xFCA854, 0xFCAC5C, 0xFCB064, 0xFCB46C, 0xFCB874,
0xFCBC7C, 0xFCC084, 0xFCC48C, 0xFCC894, 0xFCCC9C, 0xFCD0A4, 0xFCD4AC, 0xFCD8B4,
0xFCDCBC, 0xFCE0C4, 0xFCE4CC, 0xFCE8D4, 0xFCECDC, 0xFCF0E4, 0xFCF4EC, 0xFCF8F4,
0xFCFCFC, 0xFCF8F4, 0xFCF8EC, 0xFCF4E4, 0xFCF4DC, 0xFCF0D4, 0xFCF0CC, 0xFCECC4,
0xFCECBC, 0xFCE8B4, 0xFCE8AC, 0xFCE4A4, 0xFCE49C, 0xFCE094, 0xFCE08C, 0xFCDC84,
0xFCDC7C, 0xFCDC74, 0xFCD86C, 0xFCD864, 0xFCD45C, 0xFCD454, 0xFCD04C, 0xFCD044,
0xFCCC3C, 0xFCCC34, 0xFCC82C, 0xFCC824, 0xFCC41C, 0xFCC414, 0xFCC00C, 0xFCC004,
0xFCC000, 0xF4B800, 0xECB400, 0xE4AC00, 0xDCA800, 0xD4A000, 0xCC9C00, 0xC49400,
0xBC9000, 0xB48800, 0xAC8400, 0xA47C00, 0x9C7800, 0x947000, 0x8C6C00, 0x846400,
0x7C6000, 0x745800, 0x6C5400, 0x644C00, 0x5C4800, 0x544000, 0x4C3C00, 0x443400,
0x3C3000, 0x342800, 0x2C2400, 0x241C00, 0x1C1800, 0x141000, 0x0C0C00, 0x040400,
};
unsigned pal_11[] =
{
0x000000, 0x7C0880, 0x740880, 0x700C80, 0x6C1480, 0x681C7C, 0x64247C, 0x602C7C,
0x60387C, 0x60447C, 0x64507C, 0x645C80, 0x686880, 0x6C7084, 0x707C8C, 0x748494,
0x788C9C, 0x7C94A8, 0x809CB0, 0x80A0BC, 0x80A8C4, 0x80A8CC, 0x80ACD4, 0x80ACD8,
0x80ACDC, 0x7CACDC, 0x78A8D8, 0x70A8D4, 0x68A4D0, 0x60A0C8, 0x589CBC, 0x4C98B0,
0x4494A0, 0x3C9094, 0x348C84, 0x30887C, 0x2C846C, 0x288060, 0x248058, 0x24804C,
0x248048, 0x248044, 0x288040, 0x308044, 0x348044, 0x3C8048, 0x448050, 0x4C8058,
0x548060, 0x5C8068, 0x648070, 0x6C8078, 0x74807C, 0x788080, 0x7C8080, 0x808084,
0x807C84, 0x807880, 0x807880, 0x80747C, 0x807074, 0x80706C, 0x806C64, 0x806C5C,
0x7C6858, 0x7C6850, 0x7C684C, 0x7C6C48, 0x7C6C44, 0x7C7044, 0x807448, 0x807848,
0x84804C, 0x888054, 0x908858, 0x989060, 0x9C9868, 0xA4A470, 0xA8AC74, 0xB0B47C,
0xB4BC80, 0xB8C480, 0xB8CC84, 0xBCD484, 0xB8D884, 0xB8DC84, 0xB4E080, 0xB0E080,
0xA8E080, 0xA0E07C, 0x98DC78, 0x8CD874, 0x84D070, 0x7CCC70, 0x74C470, 0x68BC70,
0x60B070, 0x58A870, 0x50A074, 0x489474, 0x448C78, 0x40847C, 0x407C80, 0x407880,
0x407080, 0x446C80, 0x486880, 0x4C6480, 0x54607C, 0x586078, 0x606070, 0x64646C,
0x6C6464, 0x70685C, 0x786C54, 0x7C704C, 0x807848, 0x807C40, 0x808040, 0x808040,
0x808440, 0x808844, 0x808C4C, 0x808C54, 0x808C60, 0x808C6C, 0x808C7C, 0x808C84,
0x808898, 0x8084A8, 0x8080B8, 0x8480C4, 0x887CD4, 0x9074DC, 0x9470E8, 0x9C68EC,
0xA864F0, 0xB060F0, 0xB85CF0, 0xC458EC, 0xCC54E4, 0xD454DC, 0xDC50D0, 0xE050C4,
0xE450B8, 0xE854AC, 0xEC54A0, 0xEC5894, 0xE85C8C, 0xE86080, 0xE06480, 0xDC6878,
0xD46C78, 0xCC7074, 0xC47474, 0xBC7874, 0xB07C78, 0xA8807C, 0xA08080, 0x988080,
0x908080, 0x888084, 0x848088, 0x808088, 0x807C88, 0x807888, 0x807488, 0x807488,
0x807084, 0x846C84, 0x886880, 0x886480, 0x8C6080, 0x905C80, 0x905C80, 0x945C80,
0x945880, 0x945C84, 0x945C88, 0x905C90, 0x8C6094, 0x886498, 0x8468A0, 0x806CA4,
0x7C70A8, 0x7474AC, 0x7078B0, 0x687CB0, 0x6480B0, 0x6080B0, 0x5C84AC, 0x5884A4,
0x54849C, 0x548894, 0x54888C, 0x588484, 0x5C847C, 0x608074, 0x64806C, 0x687C64,
0x70785C, 0x747458, 0x7C6C54, 0x806854, 0x806454, 0x846058, 0x885C5C, 0x885860,
0x885868, 0x88586C, 0x845874, 0x80587C, 0x805C80, 0x786084, 0x706488, 0x6C6C88,
0x647488, 0x5C7C84, 0x548480, 0x4C8C80, 0x449878, 0x40A46C, 0x38AC64, 0x38B858,
0x34C04C, 0x34C840, 0x34D038, 0x38D830, 0x3CE028, 0x40E424, 0x44E420, 0x4CE820,
0x54E824, 0x5CE428, 0x64E42C, 0x68DC38, 0x70D840, 0x74D04C, 0x7CC858, 0x80C064,
0x80B870, 0x80B07C, 0x80A484, 0x809C8C, 0x809494, 0x80889C, 0x7C80A0, 0x7C80A0,
0x7878A4, 0x7474A4, 0x7470A0, 0x706C9C, 0x706898, 0x706894, 0x706890, 0xFCFCFC,
};
unsigned pal_12[] =
{
0x000000, 0x288834, 0x104440, 0x3C3438, 0x2C2828, 0x2C2828, 0x102828, 0x342828,
0x082828, 0x402828, 0x042828, 0x842828, 0x0C2828, 0x8C2828, 0x182828, 0x182828,
0xA42828, 0x782828, 0x442828, 0x502828, 0x582828, 0x682828, 0x782828, 0x8C2828,
0x942828, 0x9C2828, 0xA42828, 0xB02828, 0xB82828, 0xC42828, 0xD42828, 0xE02828,
0xEC2828, 0xF82828, 0xF82C2C, 0xF81C1C, 0xF84040, 0xF81818, 0xF81010, 0xF80C0C,
0xF80808, 0xF80404, 0xF80404, 0xF80808, 0xF80C0C, 0xF81010, 0xF81818, 0xF82828,
0xF83434, 0xF83C3C, 0xF84444, 0xF85050, 0xF85858, 0xF86868, 0xF87878, 0xF88C8C,
0xF89494, 0xF89C9C, 0xF8A4A4, 0xF8B0B0, 0xF8B8B8, 0xF8C4C4, 0xF8D4D4, 0xF8E0E0,
0xF8ECEC, 0xF8F8F8, 0xF8F4EC, 0xF8F4E0, 0xF8ECD4, 0xF8ECC4, 0xF8E4B8, 0xF8E4B0,
0xF8E0A4, 0xF8E09C, 0xF8D894, 0xF8D88C, 0xF8D478, 0xF8D468, 0xF8CC58, 0xF8CC50,
0xF8C444, 0xF8C43C, 0xF8C434, 0xF8C028, 0xF8C018, 0xF8B810, 0xF8B80C, 0xF8B408,
0xF8B404, 0xF8B004, 0xF8B008, 0xF8A80C, 0xF8A810, 0xF8A418, 0xF8A440, 0xF8A01C,
0xF8A02C, 0xF8A028, 0xEC9828, 0xE09428, 0xD48C28, 0xC48428, 0xB87028, 0xB06828,
0xA45828, 0x9C5828, 0x944C28, 0x8C4428, 0x783C28, 0x683828, 0x582C28, 0x502828,
0x441828, 0x3C1428, 0x340C28, 0x280C28, 0x180828, 0x100428, 0x0C0428, 0x080428,
0x040828, 0x040828, 0x080C28, 0x0C1028, 0x101828, 0x181C28, 0x403C28, 0x1C1C28,
0x2C2C28, 0x282828, 0x2C2C28, 0x1C1C28, 0x401C28, 0x186828, 0x104028, 0x0C1C28,
0x081828, 0x041428, 0x041028, 0x080C28, 0x0C0C28, 0x202020, 0x242424, 0x282428,
0x302028, 0x3C0428, 0x440428, 0x500428, 0x580828, 0x680828, 0x780C28, 0x8C0C28,
0x941028, 0x9C1428, 0xA41828, 0xB02028, 0xB82828, 0xC42C28, 0xD43428, 0xE03828,
0xEC3C28, 0xF84428, 0xF8442C, 0xF8441C, 0xF84C40, 0xF85018, 0xF85810, 0xF8580C,
0xF86008, 0xF86804, 0xF87004, 0xF87808, 0xF8840C, 0xF88C10, 0xF89018, 0xF89428,
0xF89834, 0xF89C3C, 0xF8A044, 0xF8A450, 0xF8A858, 0xF8B068, 0xF8B478, 0xF8B88C,
0xF8C094, 0xF8C49C, 0xF8CCA4, 0xF8D4B0, 0xF8D8B8, 0xF8E0C4, 0xF8E4D4, 0xF8ECE0,
0xF8F4EC, 0xF8F8F8, 0xF8F4EC, 0xF8F4E0, 0xF8ECD4, 0xF8ECC4, 0xF8E4B8, 0xF8E4B0,
0xF8E0A4, 0xF8E09C, 0xF8D894, 0xF8D88C, 0xF8D478, 0xF8D468, 0xF8CC58, 0xF8CC50,
0xF8C444, 0xF8C43C, 0xF8C434, 0xF8C028, 0xF8C018, 0xF8B810, 0xF8B80C, 0xF8B408,
0xF8B404, 0xF8B004, 0xF8B008, 0xF8A80C, 0xF8A810, 0xF8A418, 0xF8A440, 0xF8A01C,
0xF8A02C, 0xF8A028, 0xEC9828, 0xE09428, 0xD48C28, 0xC48428, 0xB87028, 0xB06828,
0xA45828, 0x9C5828, 0x944C28, 0x8C4428, 0x783C28, 0x683828, 0x582C28, 0x4C2028,
0x441828, 0x3C1428, 0x340C28, 0x280C28, 0x180830, 0x100434, 0x0C043C, 0x080440,
0x040840, 0x040844, 0x080C40, 0x0C103C, 0x101C30, 0x181C28, 0x002400, 0x1C1C28,
};
unsigned pal_13[] =
{
0x000000, 0x141414, 0x1C1C1C, 0x241818, 0x2C1C1C, 0x381C24, 0x402034, 0x482034,
0x50283C, 0x582844, 0x602C4C, 0x68305C, 0x703464, 0x78386C, 0x803C74, 0x884088,
0x904490, 0x8C4498, 0x8848A0, 0x904CA8, 0x904CB0, 0x8C4CB8, 0x8050C0, 0x8854C8,
0x8854D0, 0x8854D8, 0x7C5CDC, 0x785CE4, 0x6C64E8, 0x6C64F0, 0x6868F0, 0x6874F0,
0x80A0F0, 0x80A0F0, 0x7898F0, 0x749CF0, 0x74ACE8, 0x6CA8E0, 0x6CACD8, 0x68A4D0,
0x68A8C8, 0x64A0C0, 0x5C98B8, 0x5CA0B0, 0x5898A8, 0x58A0A0, 0x509898, 0x4C9090,
0x488878, 0x448070, 0x407868, 0x387054, 0x34684C, 0x346050, 0x30583C, 0x2C5038,
0x284428, 0x283C28, 0x203420, 0x1C2C1C, 0x242424, 0x1C1C1C, 0x141414, 0x101010,
0x101010, 0x181810, 0x202014, 0x202818, 0x24301C, 0x30381C, 0x344020, 0x484824,
0x445028, 0x4C582C, 0x606030, 0x686834, 0x707034, 0x786C38, 0x80743C, 0x88703C,
0x907840, 0x987840, 0xA06C44, 0xA87048, 0xB07048, 0xB87048, 0xBC7050, 0xC46450,
0xC86058, 0xD06058, 0xD85C5C, 0xE05C68, 0xEC6080, 0xF06080, 0xF06894, 0xF068A8,
0xF080BC, 0xF07CB8, 0xF07CB8, 0xF078C4, 0xE874C8, 0xE070C0, 0xD86CB8, 0xD06CC0,
0xC868B8, 0xC068C0, 0xB860B8, 0xA05CB0, 0x9858A8, 0x8054A0, 0x784C98, 0x744890,
0x604488, 0x604480, 0x5C4078, 0x543870, 0x383864, 0x34345C, 0x303054, 0x2C2C4C,
0x282844, 0x28283C, 0x202034, 0x1C1C2C, 0x242424, 0x142020, 0x101818, 0x101010,
0x101010, 0x101818, 0x142020, 0x182028, 0x1C3030, 0x203838, 0x204040, 0x244848,
0x285044, 0x2C584C, 0x2C604C, 0x30685C, 0x30705C, 0x387860, 0x388060, 0x388854,
0x3C905C, 0x409454, 0x449C58, 0x44A458, 0x4CAC54, 0x4CB04C, 0x50B850, 0x5CC054,
0x6CCC54, 0x74D454, 0x7CDC5C, 0x94E85C, 0xA0F060, 0xACF064, 0xB4F068, 0xC8F06C,
0xE8F084, 0xE0F080, 0xE8F080, 0xE0F07C, 0xE8E878, 0xE0E074, 0xD8C470, 0xD0C06C,
0xC8B868, 0xC0A064, 0xB8985C, 0xB08458, 0xA87C54, 0xA07850, 0x986C4C, 0x8C5C4C,
0x845444, 0x7C4040, 0x744040, 0x6C3C3C, 0x643838, 0x5C3434, 0x543030, 0x4C2C2C,
0x442828, 0x402434, 0x38202C, 0x301C24, 0x281C28, 0x201420, 0x181018, 0x101010,
0x101010, 0x181018, 0x201420, 0x281828, 0x301C30, 0x382038, 0x342040, 0x3C2448,
0x442850, 0x442858, 0x4C2C60, 0x482C68, 0x503070, 0x483474, 0x44387C, 0x443884,
0x48408C, 0x404090, 0x444498, 0x4450A4, 0x4C60AC, 0x4C60B4, 0x5070BC, 0x5080C8,
0x5488D0, 0x5898D8, 0x5CA8E0, 0x64B0E8, 0x68C4F0, 0x6CD4F0, 0x70E8F0, 0x74F0F0,
0x88F0F0, 0x84F0F0, 0x80F0E4, 0x7CF0DC, 0x74E8C4, 0x70E0C0, 0x6CD8A8, 0x68D0A0,
0x64C88C, 0x5CC084, 0x58B880, 0x5CAC6C, 0x54A464, 0x509C60, 0x4C944C, 0x4C8C4C,
0x448444, 0x407C40, 0x407440, 0x3C6C3C, 0x506834, 0x506034, 0x4C5830, 0x44502C,
0x384828, 0x344024, 0x2C3820, 0x303020, 0x28281C, 0x202014, 0x181810, 0x101010,
};


static unsigned num_valid_palettes;

#define USER_PALETTE_SIZE 16384 // See below; palette sizes actually aren't limited to this

static unsigned cur_user_palette_size = USER_PALETTE_SIZE;
//static unsigned cur_user_palette_size = 128; // for testing

// Reset this also if user palette changes
static unsigned prev_pal = 0xFFFFFFFF;

// Maximum max_iters for which lookup array is used
#define PAL_ARRAY_MAX  32768

static unsigned *pal_lookup = NULL;

int init_palettes(void)
{
   palettes[0].rgb = pal_0;
   palettes[1].rgb = pal_1;
   palettes[2].rgb = pal_2;
   palettes[3].rgb = pal_3;
   palettes[4].rgb = pal_4;
   palettes[5].rgb = pal_5;
   palettes[6].rgb = pal_6;
   palettes[7].rgb = pal_7;
   palettes[8].rgb = pal_8;
   palettes[9].rgb = pal_9;
   palettes[10].rgb = pal_10;
   palettes[11].rgb = pal_11;
   palettes[12].rgb = pal_12;
   palettes[13].rgb = pal_13;

   // To start with, allocate a user palette of USER_PALETTE_SIZE entries. If this ever turns
   // out to be too small, it will be reallocated. Will be checked for NULL later.
   palettes[NUM_PALETTES].rgb = (unsigned *) malloc(USER_PALETTE_SIZE *
                                             sizeof(palettes[NUM_PALETTES].rgb[0]));
   if (palettes[NUM_PALETTES].rgb == NULL)
      return 0;

   // Allocate the lookup array. Need one extra entry for max_iters
   pal_lookup = (unsigned *) malloc((PAL_ARRAY_MAX + 1) * sizeof(pal_lookup[0]));
   if (pal_lookup == NULL)
      return 0;
      
#ifdef PAL_MULTITHREADED
   {
      int i;
      for (i = 0; i < MAX_THREADS; i++)
         pal_events[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
   }
#endif // #ifdef PAL_MULTITHREADED
      
   return num_valid_palettes = NUM_PALETTES;
}

#endif // #ifdef PAL_GENERATE

// A comma is considered whitespace too.
#define ISWHITE(c) (c == ' ' || c == '\t' || c == ',' || c == '\n')
#define TOLOWER(c) (c | 0x20)

// Skip any leading whitespace and look for a valid number (decimal
// or hex). If one is found, puts it in val and returns the index of the
// current position. If no valid number is found, returns -1.

int get_unsigned(int ind, char *str, int size, unsigned *val)
{
   unsigned c, num, mult, have_num;

   if (ind < 0 || ind >= size)
      return -1;

   num = 0;
   mult = 10;
   have_num = 0;
   for (; ind < size; ind++)
   {
      c = str[ind];

      if (ISWHITE(c) || !c) // whitespace or end of line terminates current number
      {
         if (have_num)
         {
            *val = num;
            return ind;
         }
         else if (c)        // skip whitespace if no number yet
            continue;
         return -1;         // no number yet and end of line reached: invalid
      }

      // 'x' or 'X' chars, indicating a hex number, can have an arbitrary number
      // of leading 0's in front of them (including none).
      if (TOLOWER(c) == 'x')
      {
         if (num)       // got an 'x' and already have a number: bad value
            return -1;
         mult = 16;     // else go to hex mode
         continue;
      }

      // Check for valid digits. Only accept hex digits if in hex mode.
      if ((c - '0') <= 9)              // check dec digits; c must be unsigned
         num = num * mult + c - '0';
      else
      {
         c = TOLOWER(c) - 'a' + 10;    // check hex digits and if in hex mode
         if (c <= 15 && mult == 16)
            num = (num << 4) + c;
         else
            return -1;
      }
      have_num = 1;
   }
   return -1; // should never get here, unless line contains no ending null character
}

// Get a palette rgb value using a variety of different formats (hex/dec, individual 
// r, g, b  values or one 24-bit value). Returns 1 if it read a good value else 0.

int get_palette_rgb_val(int ind, char *str, int n, unsigned *rgb)
{
   int i;
   unsigned r, g, b;
   
   if ((i = get_unsigned(ind, str, n, &r)) < 0) // must have at least 1 good one
      return 0;
   i = get_unsigned(i, str, n, &g);
   i = get_unsigned(i, str, n, &b);

   if (i >= 0) // If all 3 were valid, use individual r, g, b values
      *rgb = ((r & 0xFF) << 16) | ((g & 0xFF) << 8) | (b & 0xFF);
   else
      *rgb = r; // else consider the first one (r) to be an rgb triplet. Allow 32-bit values
                // (palette will ignore them, and this function is used to read normal ints too)
   return 1;
}   

// Load a user palette. Returns (nonzero) index of the palette if successful, else zero.
int load_palette(FILE *fp)
{
   char str[512];
   unsigned n, rgb, *p;

   if ( (p = palettes[NUM_PALETTES].rgb) == NULL)
      return 0;

   while (1)
   {
      n = 0;
      while (1)
      {
         if (feof(fp))
            break;
         if (fgets(str, sizeof(str), fp) == NULL)
            break;

         if (!get_palette_rgb_val(0, str, sizeof(str), &rgb))
            continue;
            
         if (n < cur_user_palette_size) // Set entry if we're within array size, else just count.
            p[n] = rgb;
         n++;
      }

      if (n > cur_user_palette_size)
      {
         // oops: palette was too big to fit in our array. Need to reallocate and start over
         free(p);
         if ((p = (unsigned *) malloc(n * sizeof(palettes[NUM_PALETTES].rgb[0]))) == NULL)
            return 0;
         cur_user_palette_size = n;
         palettes[NUM_PALETTES].rgb = p;
         fseek(fp, 0, SEEK_SET);  // restart at beginning of file
      }
      else
         break; // done
   }

   // Need at least 2 entries: one for max iters and one for diverging values.
   if (n >= 2)
   {
      prev_pal = 0xFFFFFFFF; // Tell apply_palette that user palette changed
      num_valid_palettes = NUM_PALETTES + 1;
      palettes[NUM_PALETTES].size = n;
      return NUM_PALETTES;
   }
   num_valid_palettes = NUM_PALETTES;
   return 0;
}

// Create an RGB image in DEST from the color indices in SRC, using
// palette PALETTE_NUM. LINE_SIZE is the size of a horizontal line
// in pixels, and XSIZE and YSIZE are the sizes of the rectangle
// (each must be at least 1). Caller must set DEST and SRC based on
// the upper left coordinates of the rectangle to map.
//
// Any index == 0 (used for max_iters) will be set to the first entry in the
// palette. Iteration counts must not be more than MAX_ITERS - 1. SRC and DEST
// can be the same.

// Still need mod for existing legacy palettes, because their real size is 255.
// Sped up by not recalculating mod if iteration count is identical to the
// previous one. Almost as fast as using p[iters & 0xFF] for simple images

// Optimized to use direct lookup from array for max_iters <= PAL_ARRAY_MAX.

// Timings, 1600 x 1140
// Old algorithm (calculate on the fly):
// 12ms (simple image)
// 24ms (complex image)
// 10ms (simple no-mod AND 0xFF method)

// New algorithm (direct lookup, max_iters < PAL_ARRAY_MAX):
// 9ms (all images)

extern unsigned max_iters_last; // last max_iters used in a calculation

// Multi-threading the palette functions doesn't seem to speed things up much. Define
// this to try it 

#ifdef PAL_MULTITHREADED

#define MAX_THREADS  16  // set to same as in main code
HANDLE pal_events[MAX_THREADS];
extern int num_threads;

typedef struct
{
   unsigned *dest;
   unsigned *src;
   unsigned max_iters;
   unsigned iter_line_size;
   unsigned bmp_line_size;
   unsigned xsize;
   unsigned ysize;
   unsigned *pal;
   unsigned pal_size;
   int thread_num;
}  
pal_work;

pal_work pal_work_array[MAX_THREADS];

#define MIN_THREADED_PAL_MAP 200000

// New threaded palette mapping function. Called from apply_palette (the interface to
// the rest of the code). Needs to be updated to support max_iters_color
unsigned __stdcall apply_palette_threaded(pal_work *p) 
{
   unsigned iters, prev_iters, prev, x, y, bmp_line, iter_line, bmp_ind, iter_ind;
   unsigned *dest, *src, max_iters, iter_line_size, bmp_line_size, xsize, ysize, *pal, n;
   int thread_num;
   
   dest = p->dest;
   src = p->src;
   max_iters = p->max_iters;
   iter_line_size = p->iter_line_size;
   bmp_line_size = p->bmp_line_size;
   xsize = p->xsize;
   ysize = p->ysize;
   pal = p->pal;
   n = p->pal_size;
   thread_num = p->thread_num;

   if (max_iters <= PAL_ARRAY_MAX) // use the lookup table if max iters is small enough
   {
      bmp_line = 0;
      iter_line = 0;
      y = ysize;
      do
      {
         bmp_ind = bmp_line;
         iter_ind = iter_line;
         x = xsize;
         do
            dest[bmp_ind++] = pal_lookup[src[iter_ind++]];
         while (--x);
         
         bmp_line += bmp_line_size;
         iter_line += iter_line_size;
      }
      while (--y);
   }
   else // Else max iters too big: calculate on the fly
   {
      prev_iters = 0xFFFFFFFF; // non-occurring value
      bmp_line = 0;
      iter_line = 0;
      for (y = 0; y < ysize; y++)
      {
         bmp_ind = bmp_line;
         iter_ind = iter_line;
         for (x = 0; x < xsize; x++)
         {
            if ((iters = src[iter_ind]) == prev_iters)
               dest[bmp_ind] = prev;
            else
            {
               prev_iters = iters;
               if (iters != max_iters)
                  dest[bmp_ind] = prev = pal[iters % n + 1];
               else
                  dest[bmp_ind] = prev = pal[0];
            }
            bmp_ind++;
            iter_ind++;
         }
         bmp_line += bmp_line_size;
         iter_line += iter_line_size;
      }
   }
   // Tell master thread we're done. -1 is code for not threaded (to save SetEvent overhead)
   if (thread_num >= 0)
      SetEvent(pal_events[thread_num]);
   return 0;
}

void apply_palette(unsigned *dest, unsigned *src, unsigned max_iters, 
                   unsigned iter_line_size, unsigned bmp_line_size, 
                   unsigned xsize, unsigned ysize, unsigned palette_num)
{
   unsigned n, *pal, i, mod, step, nt;
   static unsigned prev_max_iters = 0;

   // NUM_PALETTES is the index used for the user palette. Num_valid_palettes is
   // NUM_PALETTES if a user palette hasn't been loaded, else NUM_PALETTES + 1.

   if (palette_num > num_valid_palettes - 1) // num_valid_palettes is NUM_PALETTES if a user
      palette_num = num_valid_palettes - 1;  // palette hasn't been loaded, else NUM_PALETTES + 1.

   pal = palettes[palette_num].rgb;
   n = palettes[palette_num].size - 1; // was 2

   // If max_iters is small enough (select PAL_ARRAY_MAX value to maximum that doesn't
   // cause cache issues- test), use the direct lookup method, else calculate on the fly

   if (max_iters <= PAL_ARRAY_MAX)
   {
      // Fill array with the colors for each possible iteration count, if palette changed
      // (or array was reallocated)
      if (prev_pal != palette_num || max_iters != max_iters_last)
      {
         for (i = mod = 0; i < max_iters; i++)
         {
            //pal_lookup[i] = p[i % n + 1]; // no need for this slow form
            if (mod == n)
               mod = 0;
            pal_lookup[i] = pal[mod + 1];
            mod++;
         }
         pal_lookup[max_iters] = pal[0]; // set max_iters value (0) to 1st entry in palette
         prev_pal = palette_num;
      }
   }
   
   // Don't bother to multithread this unless number of pixels to be done is > some minimum.
   // Otherwise threading overhead will dominate the time. 
   
   nt = num_threads;
   if ((xsize * ysize < MIN_THREADED_PAL_MAP) || nt == 1)
      nt = 1;
      
   step = ysize / nt;         // always stripe along y axis
   for (i = 0; i < nt; i++)
   {
      if (i == nt - 1)        // add any remainder onto last thread
         step += ysize - (step * nt);
         
      pal_work_array[i].dest = dest;
      pal_work_array[i].src = src;
      pal_work_array[i].max_iters = max_iters;
      pal_work_array[i].iter_line_size = iter_line_size;
      pal_work_array[i].bmp_line_size = bmp_line_size;
      pal_work_array[i].xsize = xsize;
      pal_work_array[i].ysize = step;
      pal_work_array[i].pal = pal;
      pal_work_array[i].pal_size = n;
      pal_work_array[i].thread_num = (nt == 1) ? -1 : i; // -1 is code for non-threaded
      
      dest += step * bmp_line_size;
      src += step * iter_line_size;
   }
   for (i = 1; i < nt; i++)
      QueueUserWorkItem(apply_palette_threaded, &pal_work_array[i],
                        WT_EXECUTELONGFUNCTION | ((nt - 1) << 16));
      
   // do some (or all) of the work here in the master thread                  
   apply_palette_threaded(&pal_work_array[0]);
   
   if (nt > 1)
      WaitForMultipleObjects(nt - 1, &pal_events[1], TRUE, INFINITE); // wait till all threads are done
}

#else // #ifdef PAL_MULTITHREADED

// Normal single-threaded palette mapping function

void apply_palette(unsigned *dest, unsigned *src, unsigned max_iters, 
                   unsigned iter_line_size, unsigned bmp_line_size, 
                   unsigned xsize, unsigned ysize, unsigned palette_num, int max_iters_color)
{
   unsigned n, iters, *p, i, x, y, bmp_line, iter_line, bmp_ind, iter_ind, mod;
   unsigned prev, prev_iters;
   static unsigned prev_max_iters = 0, prev_max_iters_color = 0;

   // NUM_PALETTES is the index used for the user palette. Num_valid_palettes is
   // NUM_PALETTES if a user palette hasn't been loaded, else NUM_PALETTES + 1.

   if (palette_num > num_valid_palettes - 1) // num_valid_palettes is NUM_PALETTES if a user
      palette_num = num_valid_palettes - 1;  // palette hasn't been loaded, else NUM_PALETTES + 1.

   p = palettes[palette_num].rgb;
   n = palettes[palette_num].size - 1; // was 2

   // If max_iters is small enough (select PAL_ARRAY_MAX value to maximum that doesn't
   // cause cache issues- test), use the direct lookup method, else calculate on the fly

   if (max_iters <= PAL_ARRAY_MAX)
   {
      // Fill array with the colors for each possible iteration count, if palette changed
      // (or array was reallocated)
      if (prev_pal != palette_num || max_iters != max_iters_last)
      {
         for (i = mod = 0; i < max_iters; i++)
         {
            //pal_lookup[i] = p[i % n + 1]; // no need for this slow form
            if (mod == n)
               mod = 0;
            pal_lookup[i] = p[mod + 1];
            mod++;
         }
         pal_lookup[max_iters] = p[0]; // set max_iters value (0) to 1st entry in palette
         prev_max_iters_color = p[0];
         prev_pal = palette_num;
      }
      
      if (max_iters_color >= 0)
         pal_lookup[max_iters] = max_iters_color;
      else
         pal_lookup[max_iters] = prev_max_iters_color; // restore original max iters value from array if not set
         
      // Now map the image. No measurable difference with loop unrolled 2x to reduce dependencies.
      bmp_line = 0;
      iter_line = 0;
      y = ysize;
      do
      {
         bmp_ind = bmp_line;
         iter_ind = iter_line;
         x = xsize;
         do
            dest[bmp_ind++] = pal_lookup[src[iter_ind++]];
         while (--x);
         
         bmp_line += bmp_line_size;
         iter_line += iter_line_size;
      }
      while (--y);
   }
   else // Max iters too big: calculate on the fly
   {
      if (max_iters_color < 0)
         max_iters_color = p[0]; 
   
      prev_iters = 0xFFFFFFFF; // non-occurring value
      bmp_line = 0;
      iter_line = 0;
      for (y = 0; y < ysize; y++)
      {
         bmp_ind = bmp_line;
         iter_ind = iter_line;
         for (x = 0; x < xsize; x++)
         {
            if ((iters = src[iter_ind]) == prev_iters)
               dest[bmp_ind] = prev;
            else
            {
               prev_iters = iters;
               if (iters != max_iters)
                  dest[bmp_ind] = prev = p[iters % n + 1];
               else
                  dest[bmp_ind] = prev = max_iters_color;
            }
            bmp_ind++;
            iter_ind++;
         }
         bmp_line += bmp_line_size;
         iter_line += iter_line_size;
      }
   }
}

#endif // #ifdef PAL_MULTITHREADED


